import { callHandler, support } from 'nejsbridge/dist/bridge.lofter.es';
const USER_AGENT = navigator.userAgent;

export function isWeixin() {
  return /micromessenger/i.test(USER_AGENT);
}

export function isYixin() {
  return /yixin/i.test(USER_AGENT);
}

export function isComicApp() {
  return USER_AGENT.indexOf('NeteaseComic') != -1;
}

export function isXiaomi() {
  return /XiaoMi/i.test(USER_AGENT);
}

export function isiPad() {
  return USER_AGENT.indexOf('iPad') > -1;
}

export function isYueduApp() {
  return USER_AGENT.indexOf('PRIS') != -1;
}

export function isSnail() {
  return /NeteaseSnailReader/i.test(USER_AGENT);
}

export function isMusic() {
  return /NeteaseMusic\/([\d\.]+)\b/i.test(USER_AGENT);
}

export function isLofter() {
  return /lofter/i.test(USER_AGENT);
}

export function ios() {
  return /iPad|iPhone|iPod/.test(USER_AGENT) && !window.MSStream;
}
export function isIos() {
  return ios()
}

export function isApp() {
  return isLofter() || isYueduApp() || isComicApp() || isSnail() || isMusic();
}

export function isQQ() {
  return USER_AGENT.indexOf('QQ/') !== -1;
}

export function isUpIos9() {
  return ios() && /OS [9|10|11|12|13]/i.test(USER_AGENT);
}

export function isUpIos11() {
  return ios() && /OS [11|12|13]/i.test(USER_AGENT);
}

export function isWeibo() {
  return /weibo/i.test(USER_AGENT);
}

export function isAndroid() {
  return USER_AGENT.indexOf('Android') > -1 || USER_AGENT.indexOf('Adr') > -1;
}

const WEBP_STORE_KEY = 'IS_SUPPORT_WEBP'

/**
 * 2022-03-25 优化本方法，优先读取localStorage中储存的特性检测结果，同时保证结果返回是同步的
 * 如果无储存结果，异步去计算webp支持情况并更新localStorage
 * @returns boolean 当前浏览器环境是否支持webp
 */
export function isSupportWebp() {
  const storeSupport = localStorage.getItem(WEBP_STORE_KEY);
  // 只要有localStorage的值，就直接返回
  if (storeSupport) {
    return storeSupport === 'true';
  }
  // 如果没有localStorage的值，执行计算并把结果更新到localStorage
  checkWebpSupport().then(res => {
    localStorage.setItem(WEBP_STORE_KEY, res);
  })
  const canvasTestResult = document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') === 0
  if (canvasTestResult) {
    // 只有canvas导出检测为true时才更新localstorage
    localStorage.setItem(WEBP_STORE_KEY, 'true');
  }
  return canvasTestResult;
}

const scopeAwaiter = (window && window.__awaiter) || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new(P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const scopeGenerator = (window && window.__generator) || function(thisArg, body) {
  let _ = {
      label: 0,
      sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f, y, t, g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;

  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

function checkWebpSupport() {
  return scopeAwaiter(this, void 0, void 0, function() {
    let testImageSources, testImage, results;
    return scopeGenerator(this, function(_a) {
      switch (_a.label) {
        case 0:
          testImageSources = [
            "data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICYAAACyAgCdASoCAAEALmk0mk0iIiIiIgBoSygABc6zbAAA/v56QAAAAA==",
            "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="
          ];
          testImage = function(src) {
            return new Promise(function(resolve, reject) {
              const img = document.createElement("img");
              img.onerror = function(error) {
                return resolve(false);
              };
              img.onload = function() {
                return resolve(true);
              };
              img.src = src;
            });
          };
          return [4 /*yield*/ , Promise.all(testImageSources.map(testImage))];
        case 1:
          results = _a.sent();
          return [2 /*return*/ , results.every(function(result) {
            return !!result;
          })];
      }
    });
  });
}

export function isSupportWebpAsync() {
  return new Promise(resolve => {
    const storeSupport = localStorage.getItem(WEBP_STORE_KEY);
    if (storeSupport === 'true') {
      resolve(true);
    } else {
      checkWebpSupport().then(res => {
        localStorage.setItem(WEBP_STORE_KEY, res);
        resolve(res);
      })
    }
  })
}

/**
 * 异步返回，通过JSBridge等方式，严格的检查当前H5运行环境是否为Lofter App内
 * Promise的返回值为number类型，只可能为 0 | 1 | 2这三个值之一
 * 如果当前不在客户端内，resolve 0
 * 如果当前在客户端内，并且版本高于6.8.2，resolve 1
 * 如果当前在客户端版本内，但是版本低于6.8.2，resolve 2
 * @param options
 * @param options.isDev 是否为开发环境，默认为false，传入true则表示当前为开发环境，Promise会resolve 1
 * @returns Promise<0|1|2>
 * */
export function isInLofter(
  options = {
    isDev: false,
  }
) {
  const isDev = options.isDev || false;
  return new Promise(resolve => {
    if (isDev) {
      resolve(1);
      return;
    }
    if (!isLofter()) {
      resolve(0);
      return;
    }
    // 如果1000内没有检查出App内的特征，resolve false
    let resolveTimer = setTimeout(() => {
      resolve(0);
    }, 1500);
    const clearTimer = () => {
      if (resolveTimer) {
        clearTimeout(resolveTimer);
        resolveTimer = null;
      }
    };
    if (support('njb_getDeviceInfo')) {
      callHandler('njb_getDeviceInfo', function () {
        clearTimer();
        resolve(1);
      });
    } else {
      resolve(2);
    }
  });
}

/**
 * 通过UA获取lofter端内的版本号
 * @returns {string} version 版本号，如'6.12.0'
 */
export function getLofterVersion() {
  let version = '';
  if (isLofter()) {
    let regResult = '';
    if (isAndroid()) {
      // Mozilla/5.0 (Linux; Android 8.0.0; MI 6 Build/OPR1.170623.027; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/71.0.3578.99 Mobile Safari/537.36 lofter-android 207  lofter-version 6.11.0 NEJSBridge/8
      regResult = USER_AGENT.match(/lofter-version (\d[.\d]+)/i);
    } else {
      // Mozilla/5.0 (iPhone; CPU iPhone OS 14_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 LOFTER-iPhone 6.11.0 (iPhone; iOS 14.2; zh_CN) WIFI NEJSBridge/10 /hubbledata-sdk-ios
      regResult = USER_AGENT.match(/LOFTER-iPhone (\d[.\d]+)/i);
    }
    if (regResult) {
      version = regResult[1];
    }
  }
  return version;
}

/**
 * 通过UA获取蜗牛端内的版本号
 * @returns {string} version 版本号，如'6.12.0'
 */
export function getSnailVersion() {
  let version = '';
  if (isSnail()) {
    let regResult = USER_AGENT.match(/NeteaseSnailReader[^/]*\/(\d[.\d]+).*\((.*);(.*)\)/i);
    if (regResult) {
      version = regResult[1];
    }
  }
  return version;
}

/**
 * 格式化版本号，变成可比较大小的数字，7.1.2转换为7010200,7.1.2.1转换为7010201
 * @param {string} version 想要格式化的版本号，格式必须符合 x.x.x或x.x.x.x
 * @returns {number}
 */
export const formateVersion = version => {
  if (
    !version ||
    typeof version !== 'string'
  ) {
    throw new Error('version参数错误');
  }
  const versionArray = version.split('.');
  let versionNumber = 0;
  for (var i = 0; i < 4; i++) {
    const ver = parseInt(versionArray[i] || '0');
    if (typeof ver !== 'number') {
      throw new Error('version版本号错误');
    }
    versionNumber += ver * Math.pow(100, 3 - i);
  }
  return versionNumber;
};

/**
 * 比较2个字符串版本号，返回版本号1-版本号2的结果
 * @param {string} version1 版本号1
 * @param {string} version2 版本号2
 * @returns {number} version1-version2的结果
 */
export const compareVersion = (version1, version2) => {
  if(!version1 || typeof version1 !== 'string' || version1.split('.').length){
    throw new Error('version1参数错误');
  }  
  if(!version2 || typeof version2 !== 'string' || version2.split('.').length){
    throw new Error('version2参数错误');
  }  
  const currentVersion = formateVersion(version1);
  const targetVersion = formateVersion(version2);
  return currentVersion - targetVersion; 
};

/**
 * 判断当前客户端内版本号是否大于等于给定的版本号
 * 支持Lofter和蜗牛客户端
 * @param {string} version 想要比较的版本号，x.x.x或x.x.x.x格式
 * @returns {boolean} 当前版本是否大于等于给定版本
 */
export const isUpAppVersion = (_version) => {
  if(!_version || typeof _version !== 'string'){
    throw new Error('version参数错误');
  }
  let version = '';
  if(isLofter()){
    version = getLofterVersion();
  }else if(isSnail()){
    version = getSnailVersion();
  }
  if(!version){
    return false;
  }
  const currentVersion = formateVersion(version);
  const targetVersion = formateVersion(_version);
  return currentVersion - targetVersion >= 0; 
}